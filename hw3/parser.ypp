%{
#include <iostream>
#include <memory>
#include "output.hpp"
#include "Program.h"
#include "SymbolTable.h"
#include "Expression.h"
using namespace std;
using namespace output;

//#define YYSTYPE Node*
int yylex();
extern int yylineno;
void yyerror(const char*);


%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%right ASSIGN
%left  OR
%left  AND
%left  RELOP
%left  ADDITIVE
%left  MULTIPLICATIVE
%right NOT
%left  LPAREN
%left  RPAREN
%nonassoc ELSE

%%

Program:    {openGlobScope(yylineno);}
            Funcs {checkIfMainExists();
                   closeGlobScope();}
;
Funcs:  	FuncDecl Funcs {}
            | {}
;
FuncDecl:	RetType ID {openScope();}
            {addFuncToSymbolTable($1->type, $2->name, yylineno);}
            LPAREN Formals RPAREN LBRACE Statements RBRACE {closeScope();}
;
RetType:	Type 		{$$ = $1;}
			| VOID		{$$ = shared_ptr<Expression>(new Expression(VOID));}
            |           {yyerror("");}
;
Formals:	{$$ = ExpPtr(new Expression());}
            | FormalsList 	{$$ = $1;}
;			
FormalsList: FormalDecl	{}
			| FormalDecl COMMA FormalsList	{}
;
FormalDecl:	Type ID		{$$ = $2; $$->getType() = $1->getType(); addArgToFunc($2->name,$1->type, yylineno);}
;
Statements: 	Statement	{}
				| Statements Statement	{}
;				
Statement:	LBRACE {openScope();} Statements RBRACE	{closeScope();}
			|Type ID SC					{checkNewID($2->getName(), yylineno); addVars($1->getType(), $2->getName());}
			|Type ID ASSIGN Exp SC		{checkNewID($2->getName(), yylineno); checkValidDefAndAssign($1->getType(), $4->getType(), yylineno); addVars($1->getType(), $2->getName());}
			|ID ASSIGN Exp SC			{$1=checkIdExistAndReturnId($1, yylineno); checkValidDefAndAssign($1->getType(), $3->getType(), yylineno);}
			|Call SC					{}
			|RETURN SC					{checkIsInVoidScope(yylineno);}
			|RETURN Exp SC				{checkRetType($2->getType(), yylineno);}
			|IF LPAREN MarkerOpenScope Exp MarkerCheckBool RPAREN Statement	{closeScope();}
			|IF LPAREN MarkerOpenScope Exp MarkerCheckBool RPAREN Statement MarkerCloseScope
			 ELSE MarkerOpenScope Statement		{closeScope();}
			|WHILE LPAREN MarkerOpenWhileScope Exp MarkerCheckBool RPAREN Statement	{closeScope();}				{printProductionRule(23);}
			|BREAK SC					{checkIsWhileScope(true, yylineno);}
			|CONTINUE SC				{checkIsWhileScope(false, yylineno);}
;
Call:		ID LPAREN ExpList RPAREN	{printProductionRule(26);}
			|ID LPAREN RPAREN			{printProductionRule(27);}
;
ExpList:	Exp						{printProductionRule(28);}
			|Exp COMMA ExpList		{printProductionRule(29);}
;			
Type:		INT						{printProductionRule(30);}
			|BYTE					{printProductionRule(31);}
			|BOOL					{printProductionRule(32);}
;
Exp:		LPAREN Exp RPAREN		{printProductionRule(33);}
			|Exp ADDITIVE Exp		{printProductionRule(34);}
			|Exp MULTIPLICATIVE Exp	{printProductionRule(34);}
			|ID						{printProductionRule(35);}
			|Call					{printProductionRule(36);}
			|NUM					{printProductionRule(37);}
			|NUM B					{printProductionRule(38);}
			|STRING					{printProductionRule(39);}
			|TRUE					{printProductionRule(40);}
			|FALSE					{printProductionRule(41);}
			|NOT Exp				{printProductionRule(42);}
			|Exp AND Exp			{printProductionRule(43);}
			|Exp OR Exp				{printProductionRule(44);}
			|Exp RELOP Exp			{printProductionRule(45);}
			|LPAREN Type RPAREN Exp	{printProductionRule(46);}
;


MarkerOpenScope: {openScope();}
;

MarkerCloseScope: {closeScope();}
;

MarkerCheckBool:  {checkBool($0, yylineno);}
;

MarkerOpenWhileScope: {openScope(true);}
;


%%

void yyerror(const char*){ errorSyn(yylineno);}	
int main(){
	return yyparse();
}
